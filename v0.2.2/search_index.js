var documenterSearchIndex = {"docs":
[{"location":"debiasedwhittlelikelihood/#Debiased-Whittle-likelihood","page":"Debiased Whittle likelihood","title":"Debiased Whittle likelihood","text":"","category":"section"},{"location":"debiasedwhittlelikelihood/","page":"Debiased Whittle likelihood","title":"Debiased Whittle likelihood","text":"DebiasedWhittleLikelihood","category":"page"},{"location":"debiasedwhittlelikelihood/#WhittleLikelihoodInference.DebiasedWhittleLikelihood","page":"Debiased Whittle likelihood","title":"WhittleLikelihoodInference.DebiasedWhittleLikelihood","text":"DebiasedWhittleLikelihood(model::Type{<:TimeSeriesModel}, ts, Δ; lowerΩcutoff, upperΩcutoff, taper)\nDebiasedWhittleLikelihood(model::Type{<:TimeSeriesModel}, timeseries::TimeSeries; lowerΩcutoff, upperΩcutoff, taper)\n\nGenerate a function to evaluate the Debiased Whittle likelihood it's gradient and expected Hessian.\n\nCreate a callable struct which prealloctes memory appropriately.\n\n(f::DebiasedWhittleLikelihood)(θ)\n\nEvaluates the Whittle likelihood at θ.\n\n(f::DebiasedWhittleLikelihood)(F,G,EH,θ)\n\nEvaluates the Whittle likelihood at θ and stores the gradient and expected Hessian in G and EH respectively. If F, G or EH equal nothing, then the function, gradient or expected Hessian are not evaluated repsectively.\n\nAruguments\n\nmodel: the model for the process. Should be of type TimeSeriesModel, so OU and not OU(1,1).\nts: the timeseries in the form of an n by d matrix (where d is the dimension of the time series model).\nΔ: the sampling rate of the time series.\ntimeseries: can be provided instead of ts and Δ. Must be of type TimeSeries.\nlowerΩcutoff: the lower bound of the frequency range included in the likelihood.\nupperΩcutoff: the upper bound of the frequency range included in the likelihood.\ntaper: optional taper which should be a vector of length size(ts,1), or nothing in which case no taper will be used.\n\nNote that to use the gradient the model must have grad_add_sdf! or grad_acv! specified. Similarly, to use the Hessian, the model must have hess_add_sdf! or hess_acv! specified.\n\nExamples\n\njulia> obj = DebiasedWhittleLikelihood(OU, ones(1000), 1)\nDebiased Whittle likelihood for the OU model.\n\njulia> obj([1.0, 1.0])\n-1982.0676530999626\n\njulia> F, G, EH = 0.0, zeros(2), zeros(2,2)\n(0.0, [0.0, 0.0], [0.0 0.0; 0.0 0.0])\n\njulia> obj(F, G, EH, [1.0, 1.0])\n-1982.0676530999626\n\njulia> G\n2-element Vector{Float64}:\n 1998.3136810970122\n -685.7904154568779\n\njulia> H\n2×2 Matrix{Float64}:\n -0.00967179   0.0607696\n  0.0607696   -0.381827\n\n\n\n\n\n","category":"type"},{"location":"WhittleLikelihood/#Whittle-likelihood","page":"Whittle likelihood","title":"Whittle likelihood","text":"","category":"section"},{"location":"WhittleLikelihood/","page":"Whittle likelihood","title":"Whittle likelihood","text":"WhittleLikelihood","category":"page"},{"location":"WhittleLikelihood/#WhittleLikelihoodInference.WhittleLikelihood","page":"Whittle likelihood","title":"WhittleLikelihoodInference.WhittleLikelihood","text":"WhittleLikelihood(model::Type{<:TimeSeriesModel}, ts, Δ; lowerΩcutoff, upperΩcutoff, taper)\nWhittleLikelihood(model::Type{<:TimeSeriesModel}, timeseries::TimeSeries; lowerΩcutoff, upperΩcutoff, taper)\n\nGenerate a function to evaluate the Whittle likelihood it's gradient and Hessian.\n\nCreate a callable struct which prealloctes memory appropriately.\n\n(f::WhittleLikelihood)(θ)\n\nEvaluates the Whittle likelihood at θ.\n\n(f::WhittleLikelihood)(F,G,H,θ)\n\nEvaluates the Whittle likelihood at θ and stores the gradient and Hessian in G and H respectively. If F, G or H equal nothing, then the function, gradient or Hessian are not evaluated repsectively.\n\nAruguments\n\nmodel: the model for the process. Should be of type TimeSeriesModel, so OU and not OU(1,1).\nts: the timeseries in the form of an n by d matrix (where d is the dimension of the time series model).\nΔ: the sampling rate of the time series.\ntimeseries: can be provided instead of ts and Δ. Must be of type TimeSeries.\nlowerΩcutoff: the lower bound of the frequency range included in the likelihood.\nupperΩcutoff: the upper bound of the frequency range included in the likelihood.\ntaper: optional taper which should be a vector of length size(ts,1), or nothing in which case no taper will be used.\n\nNote that to use the gradient the model must have grad_add_sdf! specified. Similarly, to use the Hessian, the model must have hess_add_sdf! specified.\n\nExamples\n\njulia> obj = WhittleLikelihood(OU, ones(1000), 1)\nWhittle likelihood for the OU model.\n\njulia> obj([1.0, 1.0])\n-2006.7870804551364\n\njulia> F, G, H = 0.0, zeros(2), zeros(2,2)\n(0.0, [0.0, 0.0], [0.0 0.0; 0.0 0.0])\n\njulia> obj(F, G, H, [1.0, 1.0])\n-2006.7870804551364\n\njulia> G\n2-element Vector{Float64}:\n   2.777354965282642\n -17.45063591068618\n\njulia> H\n2×2 Matrix{Float64}:\n -0.00967179   0.0607696\n  0.0607696   -0.381827\n\n\n\n\n\n","category":"type"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/#Generic-model-framework","page":"Models","title":"Generic model framework","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Models for time series in WhittleLikelihoodInference are specified by defining a new type which is a subtype of TimeSeriesModel{D,T} where D is the dimension of the time series and T is the type of the entry in the time series (i.e. Float64 for real valued and ComplexF64 for complex valued).","category":"page"},{"location":"models/#Univariate","page":"Models","title":"Univariate","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"So if we wish to define a univariate time series model which is real valued, we would write the following:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"struct MyUniModel <: TimeSeriesModel{1,Float64}\n    α::Float64\n    β::Float64\nend","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"In this case, we created a model called MyUniModel with parameters α and β. We then need to define the npars function to return the number of parameters, and sdf and acv.","category":"page"},{"location":"models/#Multivariate","page":"Models","title":"Multivariate","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Similarly, if we wish to define a bivariate real model, we write","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"struct My2dModel <: TimeSeriesModel{2,Float64}\n    α::Float64\n    β::Float64\nend","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"In this case, we again need to define the npars function to return the number of parameters, and now add_sdf! and acv!. add_sdf! takes a preallocated vector as its first argument. This vector is the lower triangle of the spectral density matrix at omega, and the spectral density should be added to it. The lower triangle is encoded so that it goes down each column in order, i.e. in the case D=2 we have s_11s_21s_22. The remaining entries are recovered by conjugate symmetry. acv! is analogous, but the acv replaces the preallocated vector, and not added to it.","category":"page"},{"location":"models/#Unknown-autocovariance","page":"Models","title":"Unknown autocovariance","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Sometimes, the autocovariance may not be known analytically (or may be expensive to compute). In this case, the autocovariance can be approximated from the spectral density function. To specify such a model, do the following:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"struct MyUnknownExample <: UnknownAcvTimeSeriesModel{D} end","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Then only npars and add_sdf! (sdf if univariate) need to be specified.","category":"page"},{"location":"models/#Gradients-and-Hessians","page":"Models","title":"Gradients and Hessians","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"To use gradient and Hessian features the functions grad_add_sdf!, grad_acv!, hess_add_sdf! and hess_acv! need to be specified (the acv versions should not be specified if the model is a UnknownAcvTimeSeriesModel.)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"For the gradient, the preallocated vector has first dimension the size of the lower triangle of the spectral density matrix, and second dimension the number of parameters. The Hessian is similar, but the second dimension is the lower triangle of the Hessian matrix, encoded in the same was as the lower triangle of the spectral density matrix.","category":"page"},{"location":"models/#Included-models","page":"Models","title":"Included models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"This package includes some basic models with both gradients and Hessians specified.","category":"page"},{"location":"models/#OU","page":"Models","title":"OU","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The first model is a stationary OU process, with autocovariance","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"c_X(tau) = fracsigma^2thetaexp-thetatau","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"and spectral density function","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"f_X(omega) = fracsigma^2pi(theta^2+omega^2)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The OU process can be constructed by using","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"OU(σ,θ)","category":"page"},{"location":"models/#CorrelatedOU","page":"Models","title":"CorrelatedOU","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Consider two independent OU processes X_1 and X_2 with the same sigma and theta parameters. Then define Y_1 = X_1 and Y_2 = rho X_1 + sqrt1-rho^2X_2. Then we say that Y=Y_1Y_2^T is a correlated OU process. We have that","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"mathbbEY_1(tau)Y_1(0) = c_X(tau)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"and","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"beginalign* \n    mathbbEY_2(tau)Y_2(0) = rho^2mathbbEX_1(tau)X_1(0) + (1-rho^2)mathbbEX_2(tau)X_2(0)\n    = c_X(tau)\nendalign*","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"and","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"beginalign* \n    mathbbEY_2(tau)Y_1(0) = rho c_X(tau)\nendalign*","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Therefore, we have","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"beginalign*\n    c_Y(tau) = beginbmatrix\n        c_X(tau)  rho c_X(tau) \n        rho c_X(tau)  c_X(tau)\n    endbmatrix\nendalign*","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"and","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"beginalign*\n    f_Y(omega) = beginbmatrix\n        f_X(omega)  rho f_X(omega) \n        rho f_X(omega)  f_X(omega)\n    endbmatrix\nendalign*","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"So we have taken two OU processes and correlated them with correlation parameter rho. This correlated OU process can be constructed in julia with the following:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"CorrelatedOU(σ,θ,ρ)","category":"page"},{"location":"models/#Matern","page":"Models","title":"Matern","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The package also includes an implementation of the multivariate Matérn model described by Gneiting et al. (2010). Care should be taken when using this model to ensure the correct bounds are placed on the parameter space.","category":"page"},{"location":"models/#References","page":"Models","title":"References","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Gneiting, T., Kleiber, W., & Schlather, M. (2010). Matérn cross-covariance functions for multivariate random fields. Journal of the American Statistical Association, 105(491), 1167-1177.","category":"page"},{"location":"starting/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"starting/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"WhittleLikelihoodInference.jl can be installed by running the following command:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"] add https://github.com/JakeGrainger/WhittleLikelihoodInference.jl","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"The package can then be used by running","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"using WhittleLikelihoodInference","category":"page"},{"location":"starting/#A-basic-example-(univariate)","page":"Getting Started","title":"A basic example (univariate)","text":"","category":"section"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"For a simple univariate example, consider a stationary OU process. The stationary OU process has parameters theta and sigma with autocovariance","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"c(tau) = fracsigma^2thetaexp-thetatau","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"and spectral density function","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"f(omega) = fracsigma^2pi(theta^2+omega^2)","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"The OU process is a continuous time Gaussian process, which we are interested in fitting to a sampled process which has finite length. We can simulate such a process with length n and sampling interval Delta with the following code:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"using WhittleLikelihoodInference # hide\nimport Random # hide\nRandom.seed!(1234) # hide\nσ = 2\nθ = 0.5\nn = 1000\nΔ = 0.5\nnreps = 1\nts = simulate_gp(OU(σ,θ),n,Δ,nreps)[1]","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"In this case, we only wanted one series, but simulate_gp will simulate a vector of TimeSeries of length nreps. Therefore, we pull out the first index of this array as we only want one series.","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"Alternatively, simulation can be performed by running the following:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"using WhittleLikelihoodInference # hide\nimport Random # hide\nRandom.seed!(1234) # hide\nσ = 2 # hide\nθ = 0.5 # hide\nn = 1000 # hide\nΔ = 0.5 # hide\nimport WhittleLikelihoodInference: GaussianProcess\nX = GaussianProcess(OU(σ,θ),n,Δ)\nts = rand(X)","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"To perform Whittle likelihood inference we need to first create the objective function. This is done with the following:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"using WhittleLikelihoodInference # hide\nimport Random # hide\nRandom.seed!(1234) # hide\nσ = 2 # hide\nθ = 0.5 # hide\nn = 1000 # hide\nΔ = 0.5 # hide\nnreps = 1 # hide\nts = simulate_gp(OU(σ,θ),n,Δ,nreps)[1] # hide\nwhittle_objective = WhittleLikelihood(OU,ts)","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"The resulting objective function is set up to work with Optim so we can use","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"using WhittleLikelihoodInference # hide\nimport Random # hide\nRandom.seed!(1234) # hide\nσ = 2 # hide\nθ = 0.5 # hide\nn = 1000 # hide\nΔ = 0.5 # hide\nnreps = 1 # hide\nts = simulate_gp(OU(σ,θ),n,Δ,nreps)[1] # hide\nwhittle_objective = WhittleLikelihood(OU,ts) # hide\nwhittle_objective([2, 0.5])\nF,G,H = 0,zeros(2),zeros(2,2)\nwhittle_objective(F,G,H,[2, 0.5])\nG\nH","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"We can optimise this function with Optim by using","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"using WhittleLikelihoodInference # hide\nimport Random # hide\nRandom.seed!(1234) # hide\nσ = 2 # hide\nθ = 0.5 # hide\nn = 1000 # hide\nΔ = 0.5 # hide\nnreps = 1 # hide\nts = simulate_gp(OU(σ,θ),n,Δ,nreps)[1] # hide\nwhittle_objective = WhittleLikelihood(OU,ts) # hide\nusing Optim\nconstraints = Optim.TwiceDifferentiableConstraints(zeros(2),fill(Inf,2))\nobj = TwiceDifferentiable(Optim.only_fgh!(whittle_objective),ones(2))\nres = optimize(obj, constraints, [1.5, 0.2], IPNewton())","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"The full example is:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"import Random # hide\nRandom.seed!(1234) # hide\nusing WhittleLikelihoodInference, Optim\nimport WhittleLikelihoodInference: GaussianProcess\nσ = 2\nθ = 0.5\nn = 1000\nΔ = 0.5\nts = rand(GaussianProcess(OU(σ,θ),n,Δ))\nwhittle_objective = WhittleLikelihood(OU,ts)\nconstraints = Optim.TwiceDifferentiableConstraints(zeros(2),fill(Inf,2))\nobj = TwiceDifferentiable(Optim.only_fgh!(whittle_objective),ones(2))\nres = optimize(obj, constraints, [1.5, 0.2], IPNewton())","category":"page"},{"location":"starting/#A-basic-example-(multivariate)","page":"Getting Started","title":"A basic example (multivariate)","text":"","category":"section"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"An analagous example for a multivariate process is a bivariate correlated OU process. Consider two independent OU processes X_1 and X_2 with the same sigma and theta parameters. Then define Y_1 = X_1 and Y_2 = rho X_1 + sqrt1-rho^2X_2. We have that","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"mathbbEY_1(tau)Y_1(0) = mathbbEX_1(tau)X_1(0)","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"and","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"beginalign* \n    mathbbEY_2(tau)Y_2(0) = rho^2mathbbEX_1(tau)X_1(0) + (1-rho^2)mathbbEX_2(tau)X_2(0)\n    = mathbbEX_1(tau)X_1(0)\nendalign*","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"and","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"beginalign* \n    mathbbEY_2(tau)Y_1(0) = rhomathbbEX_1(tau)X_1(0)\nendalign*","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"So we have taken two OU processes and correlated them with correlation parameter rho. We can fit the Whittle likelihood to a simulated example with the below code.","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"import Random # hide\nRandom.seed!(1234) # hide\nusing WhittleLikelihoodInference, Optim\nimport WhittleLikelihoodInference: GaussianProcess\nσ = 2\nθ = 0.5\nρ = 0.7\nn = 1000\nΔ = 0.5\nts = rand(GaussianProcess(CorrelatedOU(σ,θ,ρ),n,Δ))\nwhittle_objective = WhittleLikelihood(CorrelatedOU,ts)\nconstraints = Optim.TwiceDifferentiableConstraints(zeros(3),[Inf,Inf,1])\nobj = TwiceDifferentiable(Optim.only_fgh!(whittle_objective),ones(3))\nres = optimize(obj, constraints, [1.5, 0.2, 0.5], IPNewton())","category":"page"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"The primary concern of this package is parameter estimation using the Whittle likelihood for continuous time processes (though you can define models for discrete time if you wish).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The main concepts are as follows:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"We have some continuous-time stochastic process X(t)_tinmathbbR where X(t)inmathbbR^d for all tinmathbbR.\nWe assume that this process is mean-zero and stationary, i.e. forall t in mathbbR,\nmathbbEX(t) = 0\nmathbbEX(tau+t)X(t)^T = mathbbEX(tau)X(0)^T\ntexttr(mathbbEX(t)X(t)^T)  infty\nThe autocovariance is defined as c(tau)=mathbbEX(tau)X(0)^T.\nSampling X(t)_tinmathbbR with a sampling interval of Delta, results in a discrete-time stochastic process X_tDelta_tinmathbbZ where X_tDelta = X(tDelta) for all tinmathbbZ.\nThe spectral density function of the continuous-time process is","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"f(omega)=frac12piint_-infty^infty c(tau) e^-iomegatautextdtau","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The spectral density of the sampled process (also referred to as the aliased spectral density) is","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"f_Delta(omega)=fracDelta2pisum_tau-infty^infty c(tauDelta) e^-iomegatauDelta","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Warning: Note that the convention for the Fourier transform used here (dividing by 2pi) is essentially arbitrary, and different authors use different conventions. This only matters if you add a new model, or expect the output of a spectral density function to be the Fourier transform of the autocovariance under another convention.\nWe also have the inverse relations:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"beginalign*\n\tc(tau) = int_-infty^infty f(omega) e^iomegatau textdomega  textfor tauinmathbbR\n\tc(tauDelta) = int_-piDelta^piDelta f_Delta(omega) e^iomegatauDelta textdomega  textfor tauinmathbbZ\nendalign*","category":"page"},{"location":"#WhittleLikelihoodInference-Package","page":"Home","title":"WhittleLikelihoodInference Package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The WhittleLikelihoodInference  package provides an efficient implementation of the Whittle likelihood and debiased Whittle likelihood for univariate and multivariate time series. Features include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simulating Gaussian processes with a given autocovariance.\nWhittle likelihood and computation of gradient and Hessian (including with an arbitrary taper).\nDebiased Whittle likelihood and computation of gradient, Hessian and expected Hessian (including with an arbitrary taper).\nPlotting recipes for second-order properties of interest, including the spectral density function and autocovariance.\nApproximation of the autocovariance from the spectral density function (and for gradients and Hessians).\nExample models including 1D OU and 1D Matérn, 2D correlated OU process and arbitrary dimensional Matérn.\nBasic non-parametric estimators including the Periodogram and Bartlett's method with plotting recipes.","category":"page"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Pages   = [\"docstrings.md\"]","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [WhittleLikelihoodInference]","category":"page"},{"location":"docstrings/#WhittleLikelihoodInference.AdditiveTimeSeriesModel","page":"Docstrings","title":"WhittleLikelihoodInference.AdditiveTimeSeriesModel","text":"AdditiveTimeSeriesModel(model1, model2)\n\nConstructs an additive model from two timeseries models.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#WhittleLikelihoodInference.BartlettPeriodogram","page":"Docstrings","title":"WhittleLikelihoodInference.BartlettPeriodogram","text":"BartlettPeriodogram(timeseries, Δ, segmentlength)\n\nCompute the Bartlett periodogram for the provided timeseries with sampling rate Δ.\n\nArguments\n\ntimeseries: A Vector if univariate and an n by d Matrix if multivariate, where n is the number of observations and d is the dimension of the timeseries.\nΔ: A positive real number.\nsegmentlength: the length of series used in each segment.\n\nComputes an estimate of the spectral density function using Bartlett's method. Using the same normalisation as Periodogram.\n\nExternal links\n\nBartlett's method on Wikipedia\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#WhittleLikelihoodInference.DebiasedWhittleData","page":"Docstrings","title":"WhittleLikelihoodInference.DebiasedWhittleData","text":"DebiasedWhittleData(model::Type{<:TimeSeriesModel{D}}, timeseries, Δ; lowerΩcutoff, upperΩcutoff, taper)\n\nCreate storage for timeseries data in a format which is useful for debiased Whittle methods.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#WhittleLikelihoodInference.Periodogram","page":"Docstrings","title":"WhittleLikelihoodInference.Periodogram","text":"Periodogram(timeseries, Δ)\n\nCompute the periodogram for the provided timeseries with sampling rate Δ.\n\nArguments\n\ntimeseries: A Vector if univariate and an n by d Matrix if multivariate, where n is the number of observations and d is the dimension of the timeseries.\nΔ: A positive real number.\n\nThe periodogram is defined as\n\nboldsymbol I(ω)=boldsymbol J(ω) boldsymbol J(ω)^H quad textwhere quad boldsymbol J(ω) = sqrtfracΔ2π nsum_t=0^n-1 boldsymbolP_tΔe^-itΔ ω\n\nNote the periodogram is in terms of angular frequency here, and uses the normalisation Δ2π. The choice of normalisation is essentially arbitrary; however, this matches our definition for the spectral density function.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#WhittleLikelihoodInference.TimeSeriesModel","page":"Docstrings","title":"WhittleLikelihoodInference.TimeSeriesModel","text":"Time series model with a parameter for the dimension of the timeseries model.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#WhittleLikelihoodInference.TimeSeriesModelStorage","page":"Docstrings","title":"WhittleLikelihoodInference.TimeSeriesModelStorage","text":"TimeSeriesModelStorage\n\nPreallocated storage for model manipulation including preplanned ffts.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#WhittleLikelihoodInference.UnknownAcvTimeSeriesModel","page":"Docstrings","title":"WhittleLikelihoodInference.UnknownAcvTimeSeriesModel","text":"Sub type to specify the need for additional routines approximating the acv from the sdf. Such routines require additional storage and have different default functions in some cases.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#WhittleLikelihoodInference.WhittleData","page":"Docstrings","title":"WhittleLikelihoodInference.WhittleData","text":"WhittleData(model::Type{<:TimeSeriesModel{D}}, timeseries, Δ; lowerΩcutoff, upperΩcutoff, taper)\n\nCreate storage for timeseries data in a format which is useful for Whittle methods.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Base.:+-Tuple{TimeSeriesModel, TimeSeriesModel}","page":"Docstrings","title":"Base.:+","text":"M₁::Type{<:TimeSeriesModel{D,T}} + M₂::Type{<:TimeSeriesModel{D,T}} -> AdditiveTimeSeriesModel{M₁,M₂,D,T}\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:+-Union{Tuple{T}, Tuple{D}, Tuple{Type{var\"#s6\"} where var\"#s6\"<:TimeSeriesModel{D, T}, Type{var\"#s7\"} where var\"#s7\"<:TimeSeriesModel{D, T}}} where {D, T}","page":"Docstrings","title":"Base.:+","text":"M₁::Type{<:TimeSeriesModel{D,T}} + M₂::Type{<:TimeSeriesModel{D,T}} -> Type{AdditiveTimeSeriesModel{M₁,M₂,D,T}}\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.ndims-Union{Tuple{TimeSeriesModel{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Docstrings","title":"Base.ndims","text":"ndims(::TimeSeriesModel) -> Integer\nndims(::Type{<:TimeSeriesModel}) -> Integer\n\nReturn the dimension of a timeseries model.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.EI!-Tuple{Union{WhittleLikelihoodInference.TimeSeriesModelStorageFunction, WhittleLikelihoodInference.AdditiveStorage}, TimeSeriesModel}","page":"Docstrings","title":"WhittleLikelihoodInference.EI!","text":"EI!(store, model::TimeSeriesModel)\n\nCompute the expected periodogram and assign to appropriate place in memory (note this computes at twice the desired resolution).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.EI-Tuple{TimeSeriesModel, Any, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.EI","text":"EI(model::TimeSeriesModel, n, Δ)\n\nCompute EI at Fourier frequencies fftshift(fftfreq(n,2π/Δ)).\n\nNote internal computation provides values at twice the resolution, this function returns at the desired resolution.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.acv!-Tuple{Any, TimeSeriesModel, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.acv!","text":"acv!(out, model::TimeSeriesModel, τ)\n\nCompute the acv for a single lag and when acv is known.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.acv!-Tuple{WhittleLikelihoodInference.Acv2EIStorage, TimeSeriesModel, WhittleLikelihoodInference.LagsEI}","page":"Docstrings","title":"WhittleLikelihoodInference.acv!","text":"acv!(store::Acv2EIStorage, model::TimeSeriesModel, encodedtime::LagsEI)\n\nCompute the acv at many lags and allocate to storage when acv is known.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.acv!-Tuple{WhittleLikelihoodInference.AdditiveStorage, AdditiveTimeSeriesModel}","page":"Docstrings","title":"WhittleLikelihoodInference.acv!","text":"acv!(store::AdditiveStorage, model::AdditiveTimeSeriesModel)\n\nCompute the acv for an additive model.\n\nProcesses storage and model, and computes acv for each separately, then combines and stores in the leftmost storage. In other words, the sum of both autocovariances is stores in store 1. This is preferable as for some models the acv may be known.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.acv!-Tuple{WhittleLikelihoodInference.Sdf2EIStorage, UnknownAcvTimeSeriesModel, WhittleLikelihoodInference.FreqAcvEst}","page":"Docstrings","title":"WhittleLikelihoodInference.acv!","text":"acv!(store::Sdf2EIStorage, model::UnknownAcvTimeSeriesModel, encodedtime::FreqAcvEst)\n\nApproximate the acv and allocate to storage when acv is unknown.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.acv!-Tuple{WhittleLikelihoodInference.TimeSeriesModelStorageFunction, TimeSeriesModel}","page":"Docstrings","title":"WhittleLikelihoodInference.acv!","text":"acv!(store::TimeSeriesModelStorageFunction, model::TimeSeriesModel)\n\nUnwrap storage and pass to lower level acv! call.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.acv!-Union{Tuple{T}, Tuple{WhittleLikelihoodInference.Acv2EIStorageUni, TimeSeriesModel{1, T}, WhittleLikelihoodInference.LagsEI}} where T","page":"Docstrings","title":"WhittleLikelihoodInference.acv!","text":"acv!(store::Acv2EIStorageUni, model::TimeSeriesModel{1,T}, encodedtime::LagsEI)\n\nCompute the acv at many lags and allocate to storage when acv is known in the univariate case.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.acv!-Union{Tuple{T}, Tuple{WhittleLikelihoodInference.Sdf2EIStorageUni, UnknownAcvTimeSeriesModel{1, T}, WhittleLikelihoodInference.FreqAcvEst}} where T","page":"Docstrings","title":"WhittleLikelihoodInference.acv!","text":"acv!(store::Sdf2EIStorageUni, model::UnknownAcvTimeSeriesModel{1,T}, encodedtime::FreqAcvEst)\n\nApproximate the acv and allocate to storage when acv is known in the univariate case.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.acv-Tuple{TimeSeriesModel, Any, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.acv","text":"acv(model::TimeSeriesModel, n, Δ)\n\nCompute acv at lags -(n-1)*Δ:Δ:(n-1)*Δ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.acv-Tuple{TimeSeriesModel, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.acv","text":"acv(model::TimeSeriesModel, τ)\n\nCompute acv at τ, provided acv is known.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.add_asdf!-Tuple{Any, TimeSeriesModel, Any, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.add_asdf!","text":"add_asdf!(out, model::TimeSeriesModel, ω, Δ)\n\nAdd the aliased sdf of a model to a storage vector.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.add_sdf!-Tuple{Any, TimeSeriesModel, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.add_sdf!","text":"add_sdf!(out, model::TimeSeriesModel, ω)\n\nAdd the sdf of a model to a storage vector.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.asdf!-Tuple{Any, TimeSeriesModel, Any, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.asdf!","text":"asdf!(out, model::TimeSeriesModel, ω, Δ)\n\nComputes the asdf and overwrites a storage vector.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.asdf!-Tuple{WhittleLikelihoodInference.TimeSeriesModelStorage, TimeSeriesModel, WhittleLikelihoodInference.FreqAcvEst}","page":"Docstrings","title":"WhittleLikelihoodInference.asdf!","text":"asdf!(store::TimeSeriesModelStorage, model::TimeSeriesModel, freq::FreqAcvEst)\n\nCompute the asdf for all frequencies and allocates to appropriate location in storage.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.asdf-Tuple{TimeSeriesModel, Any, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.asdf","text":"asdf(model::TimeSeriesModel, ω, Δ)\n\nCompute asdf with sampling rate Δ at ω.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.checkparameterlength-Tuple{Any, Type{var\"#s6\"} where var\"#s6\"<:TimeSeriesModel}","page":"Docstrings","title":"WhittleLikelihoodInference.checkparameterlength","text":"checkparameterlength(x,model::Type{<:TimeSeriesModel})\n\nchecks if the parameter vector is the correct length for the given model.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.checkposreal-Tuple{Any}","page":"Docstrings","title":"WhittleLikelihoodInference.checkposreal","text":"checkposreal(x)\n\nChecks if x is a positive real number.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.coherance-Tuple{TimeSeriesModel, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.coherance","text":"coherance(model::TimeSeriesModel, ω)\n\nCompute the coherance of a given model at frequency ω.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.coherancy-Union{Tuple{D}, Tuple{TimeSeriesModel{D, T} where T, Any}} where D","page":"Docstrings","title":"WhittleLikelihoodInference.coherancy","text":"coherancy(model::TimeSeriesModel, ω)\n\nCompute the coherancy of a given model at frequency ω.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.debiasedwhittle!-Tuple{WhittleLikelihoodInference.TimeSeriesModelStorage, TimeSeriesModel, WhittleLikelihoodInference.GenWhittleData}","page":"Docstrings","title":"WhittleLikelihoodInference.debiasedwhittle!","text":"debiasedwhittle!(store::TimeSeriesModelStorage, model::TimeSeriesModel, data::GenWhittleData)\n\nFunction to compute the debiased Whittle likelihood using a preallocated store.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.debiasedwhittle_Ehess!-Tuple{Any, Any, WhittleLikelihoodInference.GenWhittleData}","page":"Docstrings","title":"WhittleLikelihoodInference.debiasedwhittle_Ehess!","text":"debiasedwhittle_Ehess!(EH, store, data::GenWhittleData)\n\nCompute the expected hessian of the de-biased Whittle likelihood.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.debiasedwhittle_FG!-Tuple{Any, Any, Any, TimeSeriesModel, WhittleLikelihoodInference.GenWhittleData}","page":"Docstrings","title":"WhittleLikelihoodInference.debiasedwhittle_FG!","text":"debiasedwhittle_FG!(F, G, store, model::TimeSeriesModel, data::GenWhittleData)\n\nCompute the debiased Whittle likelihood and its gradient using a preallocated store.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.debiasedwhittle_FGH!-Tuple{Any, Any, Any, Any, TimeSeriesModel, WhittleLikelihoodInference.GenWhittleData}","page":"Docstrings","title":"WhittleLikelihoodInference.debiasedwhittle_FGH!","text":"debiasedwhittle_FGH!(F, G, H, store, model::TimeSeriesModel, data::GenWhittleData)\n\nCompute the debiased Whittle likelihood and its gradient and hessian using a preallocated store.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.debiasedwhittle_Fisher!-Tuple{Any, Any, Any, Any, TimeSeriesModel, WhittleLikelihoodInference.GenWhittleData}","page":"Docstrings","title":"WhittleLikelihoodInference.debiasedwhittle_Fisher!","text":"debiasedwhittle_Fisher!(F, G, H, store, model::TimeSeriesModel, data::GenWhittleData)\n\nCompute the debiased Whittle likelihood, its gradient and fisher information.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.extract_EI-Tuple{Any}","page":"Docstrings","title":"WhittleLikelihoodInference.extract_EI","text":"extract_EI(store::Sdf2EIStorage)\nextract_EI(store::Acv2EIStorage)\nextract_EI(store::Sdf2EIStorageUni)\nextract_EI(store::Acv2EIStorageUni)\n\nExtract the EI from general storage.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.extract_acv-Tuple{Any}","page":"Docstrings","title":"WhittleLikelihoodInference.extract_acv","text":"extract_acv(store::Sdf2EIStorage)\nextract_acv(store::Acv2EIStorage)\nextract_acv(store::Sdf2EIStorageUni)\nextract_acv(store::Acv2EIStorageUni)\n\nExtract the acv from general storage.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.extract_array-Tuple{WhittleLikelihoodInference.Sdf2EIStorage}","page":"Docstrings","title":"WhittleLikelihoodInference.extract_array","text":"extract_array(store::Sdf2EIStorage)\nextract_array(store::Acv2EIStorage)\nextract_array(store::Sdf2EIStorageUni)\nextract_array(store::Acv2EIStorageUni)\n\nExtract array from storage.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.getallderiv-Tuple{WhittleLikelihoodInference.AdditiveStorage}","page":"Docstrings","title":"WhittleLikelihoodInference.getallderiv","text":"getallderiv(store::AdditiveStorage)\ngetallderiv(store::TimeSeriesModelStorageGradient)\n\nExtract all of the derivatives from a generic store.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.grad_EI!-Tuple{WhittleLikelihoodInference.TimeSeriesModelStorageGradient, TimeSeriesModel}","page":"Docstrings","title":"WhittleLikelihoodInference.grad_EI!","text":"grad_EI!(store::TimeSeriesModelStorageGradient, model::TimeSeriesModel)\n\nCompute the gradient of the expected periodogram and assign to appropriate place in memory (note this computes at twice the desired resolution).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.grad_acv!-Tuple{WhittleLikelihoodInference.Sdf2EIStorage, UnknownAcvTimeSeriesModel, WhittleLikelihoodInference.FreqAcvEst}","page":"Docstrings","title":"WhittleLikelihoodInference.grad_acv!","text":"grad_acv!\n\nCompute the gradient of the acv and allocate to storage as appropriate.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.grad_acv-Tuple{TimeSeriesModel, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.grad_acv","text":"grad_acv(model::TimeSeriesModel, τ)\n\nCompute the gradient of the acv at τ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.grad_add_asdf!-Tuple{Any, TimeSeriesModel, Any, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.grad_add_asdf!","text":"grad_add_asdf!(out, model::TimeSeriesModel, ω, Δ)\n\nAdd the gradient of the aliased sdf of a model to an input storage vector.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.grad_add_sdf!-Tuple{Any, TimeSeriesModel, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.grad_add_sdf!","text":"grad_add_sdf!(out, model::TimeSeriesModel, ω)\n\nAdd the gradient of the sdf of a model to an input storage vector.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.grad_asdf!-Tuple{Any, TimeSeriesModel, Any, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.grad_asdf!","text":"grad_asdf!(out, model::TimeSeriesModel, ω, Δ)\n\nCompute the gradient of the aliased sdf of a model and store in storage vector.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.grad_asdf!-Tuple{WhittleLikelihoodInference.TimeSeriesModelStorage, TimeSeriesModel, WhittleLikelihoodInference.FreqAcvEst}","page":"Docstrings","title":"WhittleLikelihoodInference.grad_asdf!","text":"grad_asdf!(store::TimeSeriesModelStorage, model::TimeSeriesModel, freq::FreqAcvEst)\ngrad_asdf!(store::TimeSeriesModelStorageGradient, model::TimeSeriesModel)\n\nCompute the gradient of the asdf for all frequencies and allocate to appropriate location in storage.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.grad_sdf-Tuple{TimeSeriesModel, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.grad_sdf","text":"grad_sdf(model::TimeSeriesModel, ω)\n\nCompute the gradient of the sdf at ω.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.groupdelay-Tuple{TimeSeriesModel, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.groupdelay","text":"groupdelay(model::TimeSeriesModel, ω)\n\nCompute the groupdelay of a given model at frequency ω.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.hess_EI!-Tuple{WhittleLikelihoodInference.TimeSeriesModelStorageHessian, TimeSeriesModel}","page":"Docstrings","title":"WhittleLikelihoodInference.hess_EI!","text":"hess_EI!(store::TimeSeriesModelStorageHessian, model::TimeSeriesModel)\n\nCompute the Hessian of the expected periodogram and assign to appropriate place in memory (note this computes at twice the desired resolution).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.hess_acv!-Tuple{WhittleLikelihoodInference.Sdf2EIStorage, UnknownAcvTimeSeriesModel, WhittleLikelihoodInference.FreqAcvEst}","page":"Docstrings","title":"WhittleLikelihoodInference.hess_acv!","text":"hess_acv!\n\nCompute the Hessian of the acv and allocate to storage as appropriate.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.hess_add_asdf!-Tuple{Any, TimeSeriesModel, Any, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.hess_add_asdf!","text":"hess_add_asdf!(out, model::Type{<:TimeSeriesModel}, ω, Δ)\n\nAdd the Hessian of the aliased sdf of a model to an input storage vector.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.hess_add_sdf!-Tuple{Any, TimeSeriesModel, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.hess_add_sdf!","text":"hess_add_sdf!(out, model::TimeSeriesModel, ω)\n\nAdd the Hessian of the sdf of a model to an input storage vector.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.hess_asdf!-Tuple{Any, TimeSeriesModel, Any, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.hess_asdf!","text":"hess_asdf!(out, model::TimeSeriesModel, ω, Δ)\n\nCompute the Hessian of the aliased sdf of a model and store in storage vector.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.hess_asdf!-Tuple{WhittleLikelihoodInference.TimeSeriesModelStorage, TimeSeriesModel, WhittleLikelihoodInference.FreqAcvEst}","page":"Docstrings","title":"WhittleLikelihoodInference.hess_asdf!","text":"hess_asdf!(store::TimeSeriesModelStorage, model::TimeSeriesModel, freq::FreqAcvEst)\nhess_asdf!(store::TimeSeriesModelStorageHessian, model::TimeSeriesModel)\n\nCompute the Hessian of the asdf for all frequencies and allocate to appropriate location in storage.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.hess_sdf-Tuple{TimeSeriesModel, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.hess_sdf","text":"hess_sdf(model::TimeSeriesModel, ω)\n\nCompute the Hessian of the sdf at ω.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.indexLT-Tuple{Int64, Int64, Int64}","page":"Docstrings","title":"WhittleLikelihoodInference.indexLT","text":"indexLT(i,j,d)\n\nReturn the lower triangle index for an elements of a symmetric matrix assuming the lower triangle is encoded down the columns.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.minbins-Tuple{Type{var\"#s6\"} where var\"#s6\"<:TimeSeriesModel}","page":"Docstrings","title":"WhittleLikelihoodInference.minbins","text":"minbins(model::TimeSeriesModel)\n\nReturns the minimum number of bins required for a good approximation of the sdf from the acv for a given model.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.nalias-Tuple{TimeSeriesModel}","page":"Docstrings","title":"WhittleLikelihoodInference.nalias","text":"nalias(model::TimeSeriesModel)\n\nReturns the number of times a sdf should be alised for a given model.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.nlowertriangle_dimension-Union{Tuple{TimeSeriesModel{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Docstrings","title":"WhittleLikelihoodInference.nlowertriangle_dimension","text":"nlowertriangle_dimension(::TimeSeriesModel) -> Integer\nnlowertriangle_dimension(::Type{<:TimeSeriesModel}) -> Integer\n\nReturn the number of elements in the lower triangle the spectral density matrix function of a timeseries model.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.nlowertriangle_parameter-Tuple{TimeSeriesModel}","page":"Docstrings","title":"WhittleLikelihoodInference.nlowertriangle_parameter","text":"nlowertriangle_parameter(::TimeSeriesModel) -> Integer\nnlowertriangle_parameter(::Type{<:TimeSeriesModel}) -> Integer\n\nReturn the number of elements in the lower triangle of the hessian matrix for a model with given number of parameters.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.parameternames-Tuple{TimeSeriesModel}","page":"Docstrings","title":"WhittleLikelihoodInference.parameternames","text":"parameternames(::TimeSeriesModel)\nparameternames(::Type{<:TimeSeriesModel})\n\nReturn the parameter names for a given timeseries model.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.plotacv","page":"Docstrings","title":"WhittleLikelihoodInference.plotacv","text":"plotacv(model)\nplotacv!(model)\nplotacv(model, τ)\nplotacv!(model, τ)\nplotacv(model, n, Δ)\nplotacv!(model, n, Δ)\n\nPlot the aliased spectral density function of a model at lags τ. If the model does not have known acv, then the number of lags n and sampling rate Δ should be provided. In this case, the lags are -(n-1)*Δ:Δ:(n-1)*Δ. If unprovided, n = 30 and Δ = 1.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#WhittleLikelihoodInference.plotasdf","page":"Docstrings","title":"WhittleLikelihoodInference.plotasdf","text":"plotasdf(model)\nplotasdf!(model)\nplotasdf(model, Ω, Δ)\nplotasdf!(model, Ω, Δ)\n\nPlot the aliased spectral density function of a model at the frequencies Ω.  By default, Ω = range(-π,π,length=200) and Δ = 1.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#WhittleLikelihoodInference.plotcoh","page":"Docstrings","title":"WhittleLikelihoodInference.plotcoh","text":"plotcoh(model)\nplotcoh!(model)\nplotcoh(model, Ω)\nplotcoh!(model, Ω)\n\nPlot the coherance and group delay of a model at the frequencies Ω.  If multivariate, above the diagonal is the coherance, and below is the group delay and on the diagonal is the spectral density function. By default, Ω = range(-π,π,length=200) and Δ = 1.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#WhittleLikelihoodInference.plotei","page":"Docstrings","title":"WhittleLikelihoodInference.plotei","text":"plotei(model)\nplotei!(model)\nplotei(model, n, Δ)\nplotei!(model, n, Δ)\n\nPlot the aliased spectral density function of a model at the angular Fourier frequencies fftfreq(n,2π/Δ).  By default, n = 1024 and Δ = 1.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#WhittleLikelihoodInference.plotsdf","page":"Docstrings","title":"WhittleLikelihoodInference.plotsdf","text":"plotsdf(model)\nplotsdf!(model)\nplotsdf(model, Ω)\nplotsdf!(model, Ω)\n\nPlot the spectral density function of a model at the frequencies Ω.  By default, Ω = range(-π,π,length=200) and Δ = 1.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#WhittleLikelihoodInference.sdf-Tuple{TimeSeriesModel, Any}","page":"Docstrings","title":"WhittleLikelihoodInference.sdf","text":"sdf(model::TimeSeriesModel, ω)\n\nCompute sdf at ω.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.whittle!-Tuple{Any, TimeSeriesModel, WhittleLikelihoodInference.GenWhittleData}","page":"Docstrings","title":"WhittleLikelihoodInference.whittle!","text":"whittle!(store, model::TimeSeriesModel, data::GenWhittleData)\n\nCompute the Whittle likelihood using a preallocated store.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.whittle_FG!-Tuple{Any, Any, Any, TimeSeriesModel, WhittleLikelihoodInference.GenWhittleData}","page":"Docstrings","title":"WhittleLikelihoodInference.whittle_FG!","text":"whittle_FG!(F, G, store, model::TimeSeriesModel, data::GenWhittleData)\n\nCompute the Whittle likelihood and its gradient using a preallocated store.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#WhittleLikelihoodInference.whittle_FGH!-Tuple{Any, Any, Any, Any, TimeSeriesModel, WhittleLikelihoodInference.GenWhittleData}","page":"Docstrings","title":"WhittleLikelihoodInference.whittle_FGH!","text":"whittle_FGH!(F, G, H, store, model::TimeSeriesModel, data::GenWhittleData)\n\nCompute the debiased Whittle likelihood and its gradient and hessian using a preallocated store.\n\n\n\n\n\n","category":"method"}]
}
